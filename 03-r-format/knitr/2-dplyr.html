<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>dplyr</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.8/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script>
    <link href="libs/bokehjs-0.12.5/bokeh.min.css" rel="stylesheet" />
    <link href="libs/bokehjs-0.12.5/loader.css" rel="stylesheet" />
    <script src="libs/bokehjs-0.12.5/bokeh.min.js"></script>
    <script src="libs/rbokeh-binding-0.5.2/rbokeh.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# dplyr
### 

---





## The pipe operator `%&gt;%`

`f(x) %&gt;% g(y)` is equivalent to `g(f(x), y)`

i.e. the output of one function is used as input to the next function. This function can be the identity

Consequences:

- `x %&gt;% f(y)` is the same as `f(x, y)`

- statements of the form `k(h(g(f(x, y), z), u), v, w)` become
`x %&gt;% f(y) %&gt;% g(z) %&gt;% h(u) %&gt;% k(v, w)`

- read `%&gt;%` as "then do"

- in non-mathematical terms, the piping operator allows you to apply more than one different function at the same time to the same data frame.

---
## dplyr terminology

There are some of the primary `dplyr` *verbs*, representing distinct data analysis tasks:

- **Filter**: Select specified rows of a data frame, produce subsets

- **Arrange**: Reorder the rows of a data frame

- **Select**: Select particular columns of a data frame

- **Mutate**: Add new or change existing columns of the data frame (as functions of existing columns)

- **Summarise**: Create collapsed summaries of a data frame

- **Group By**: Introduce structure to a data frame
 
 
---

## Filter

Read in the pitch data set (in the folder 03-r-format/data). The data are from an experiment on different advanced metrics of MLB baseball pitchers different pitch types.


```
## # A tibble: 6 × 8
##      X1 playerid pitcher_hand pitch_type spin_rate ab_result action_result adj_h
##   &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;
## 1     1     2795 R            CU             3000. "\\N"     F                 0
## 2     3     2795 R            CU             3146. "\\N"     B                 0
## 3     4     3646 R            CU             3012. "\\N"     B                 0
## 4     5     2795 R            CU             3026. "HB"      B                 0
## 5     8     2795 R            CU             3261. "\\N"     F                 0
## 6     9      476 R            CU             3025. "\\N"     B                 0
```

`filter` is similar to the base function `subset`

---
## Filter (cont.)

Multiple conditions in `filter` are combined with a logical AND (i.e. all conditions must be fulfilled) 

e.g. `filter(pitcher_hand == "R", pitch_type == "CU")`

Logical expressions can also be used 

e.g. `filter(pitcher_hand == "R" &amp;  pitch_type == "CU")` or 
`filter(pitch_type == "CU" | subject == "KN")`

---
class: inverse
## Your Turn (~3 minutes) 

1. Use `filter` to get a subset of the `pitchdata` dataset

2. Ex. Filter the data down to left handed pitchers, who throw a curve with at least
3300 rpms (spin_rate), and the play results in a ball (action_result).

3. `%&gt;%` the subset and create a plot

hint: what is the default first argument of the `ggplot` function?

---

## One Solution 


```r
  pitch %&gt;%
  filter(spin_rate &gt;= 3300 &amp; pitcher_hand == "L") %&gt;%
  ggplot(aes(x=action_result, y=spin_rate)) +
  geom_point(aes(color=playerid)) +
  theme(legend.position = "none")
```

![](2-dplyr_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---

## Another Solution (interactive edition)


```r
library(rbokeh)
 pitch %&gt;%
  filter(spin_rate &gt;= 3300 &amp; pitcher_hand == "L") %&gt;%
  figure() %&gt;%
  ly_points(x = action_result, y = spin_rate, color = playerid, hover = list(playerid, spin_rate, action_result), legend = FALSE) 
```

<div id="htmlwidget-90a1b00bd496a48eebb1" style="width:504px;height:216px;" class="rbokeh html-widget"></div>
<script type="application/json" data-for="htmlwidget-90a1b00bd496a48eebb1">{"x":null,"evals":[],"jsHooks":null}</script>

---


## Arrange
 -Easy way to arrange your data in ascending or descending order

```r
pitch %&gt;% 
  subset(select = c("playerid", "spin_rate")) %&gt;%
  arrange(desc(playerid), spin_rate) %&gt;% 
  head(5)
```

```
## # A tibble: 5 × 2
##   playerid spin_rate
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1    16669     3056.
## 2    16669     3072.
## 3    16669     3075.
## 4    16669     3165.
## 5    15686     3033.
```

Successive variables are used for breaking ties from previous variables.


```r
pitch %&gt;% 
  subset(select = c("playerid", "spin_rate")) %&gt;%
  arrange(playerid, spin_rate) %&gt;% 
  head(5)
```

```
## # A tibble: 5 × 2
##   playerid spin_rate
##      &lt;dbl&gt;     &lt;dbl&gt;
## 1      476     3013.
## 2      476     3017.
## 3      476     3025.
## 4      476     3028.
## 5      476     3040.
```

---
class: inverse

## Your Turn

1. Look up the help file for the function `slice`.

2. Use `slice` on the arranged `pitchdata` dataset to select a single row

3. use `slice` to select multiple rows

Hint: Use the entire data set

---

## Solution


```r
pitch %&gt;% 
  arrange(desc(playerid), spin_rate) %&gt;% 
  slice(11)
```

```
## # A tibble: 1 × 8
##      X1 playerid pitcher_hand pitch_type spin_rate ab_result action_result adj_h
##   &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;
## 1   664    15540 R            CU             3042. "\\N"     F                 0
```


```r
pitch %&gt;% 
  arrange(desc(playerid), spin_rate) %&gt;% 
  slice(1:5)
```

```
## # A tibble: 5 × 8
##      X1 playerid pitcher_hand pitch_type spin_rate ab_result action_result adj_h
##   &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;
## 1   966    16669 R            CU             3056. "\\N"     C                 0
## 2  1136    16669 R            CU             3072. "\\N"     B                 0
## 3  1165    16669 R            CU             3075. "\\N"     B                 0
## 4  1411    16669 R            CU             3165. "\\N"     C                 0
## 5   649    15686 R            CU             3033. "K"       S                 0
```

---

## Select
 - Using Select we are easily able to create a subset of our data. This is similar to
 the subset function in base.

```r
pitch %&gt;% 
  select(playerid, pitcher_hand, action_result, spin_rate) %&gt;%
  head()
```

```
## # A tibble: 6 × 4
##   playerid pitcher_hand action_result spin_rate
##      &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;             &lt;dbl&gt;
## 1     2795 R            F                 3000.
## 2      959 L            C                 3052.
## 3     2795 R            B                 3146.
## 4     3646 R            B                 3012.
## 5     2795 R            B                 3026.
## 6     2795 L            B                 3039.
```

---

## Summarise
 - Finding summary statistics of a metric

```r
pitch %&gt;%
    summarise(mean_spinrate = mean(spin_rate, na.rm=TRUE), 
              sd_spinrate = sd(spin_rate, na.rm = TRUE))
```

```
## # A tibble: 1 × 2
##   mean_spinrate sd_spinrate
##           &lt;dbl&gt;       &lt;dbl&gt;
## 1         3126.        110.
```

---

## Summarise and Group_by
 - Finding summary statistics of a metric after accounting first for other variables

```r
pitch %&gt;%
    group_by(playerid) %&gt;%
    summarise(mean_spinrate = mean(spin_rate, na.rm=TRUE), 
              sd_spinrate = sd(spin_rate, na.rm = TRUE))
```

```
## # A tibble: 65 × 3
##    playerid mean_spinrate sd_spinrate
##       &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;
##  1      476         3066.       44.6 
##  2      607         3278.       NA   
##  3      657         3042.       43.0 
##  4      959         3056.       42.9 
##  5     1030         3044.       37.7 
##  6     1241         3004.        4.54
##  7     1489         3068.        2.53
##  8     1802         3239.      130.  
##  9     1828         3058.       52.4 
## 10     1862         3062.       39.6 
## # … with 55 more rows
```

---
class: inverse

## Your Turn

1. Select only playerid, spin_rate, and action result

2. Group by both playerid and action result and find mean and sd of spin rates 

3.`%&gt;%` the summaries into a `ggplot` histogram

---

## A Solution


```r
pitch %&gt;%
  select(playerid, spin_rate, action_result) %&gt;%
    group_by(playerid, action_result) %&gt;%
    summarise(mean_spin = mean(spin_rate), sd_spin = sd(spin_rate)) %&gt;%
  ggplot(aes(x = mean_spin)) + geom_histogram()
```

![](2-dplyr_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;

---

## Mutate

 -Change an existing or create a new variable into the data
 -Creating a new column in your data set that represents something new
 -Great for calculations 
 -How would I create a calculation for how far above or below each players pitches are from their own average spin rates?

```r
pitch %&gt;%
    select(playerid, spin_rate, action_result) %&gt;%
    group_by(playerid, action_result) %&gt;%
    summarise(mean_spin = mean(spin_rate), sd_spin = sd(spin_rate)) %&gt;%
    mutate(mean = sum(mean_spin) / n()) %&gt;%
    mutate(difference = mean - mean_spin)
```

```
## `summarise()` has grouped output by 'playerid'. You can override using the `.groups` argument.
```

```
## # A tibble: 218 × 6
## # Groups:   playerid [65]
##    playerid action_result mean_spin sd_spin  mean difference
##       &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;
##  1      476 B                 3077.   52.1  3058.     -19.1 
##  2      476 F                 3101.    1.69 3058.     -43.4 
##  3      476 S                 3041.   17.0  3058.      17.2 
##  4      476 X                 3013.   NA    3058.      45.3 
##  5      607 B                 3278.   NA    3278.       0   
##  6      657 B                 3047.   46.2  3036.     -11.2 
##  7      657 F                 3025.   34.7  3036.      11.2 
##  8      959 B                 3066.   53.6  3057.      -9.56
##  9      959 C                 3039.   35.6  3057.      18.0 
## 10      959 F                 3054.   38.1  3057.       3.00
## # … with 208 more rows
```

---
## Utilzing ifelse
-Sometimes you are tasked to create a new column based on a clause
-ifelse function allows you to create an if else statement within the creation 
of the new variable.
-Consider rewriting the handedness of our pitchers.
-If the pitcher_hand is R write "Right" if not, "Left"

```r
pitch %&gt;% 
  select(pitcher_hand) %&gt;% mutate(Handedness = ifelse(pitcher_hand == "R", "Right", "Left"))
```

```
## # A tibble: 2,239 × 2
##    pitcher_hand Handedness
##    &lt;chr&gt;        &lt;chr&gt;     
##  1 R            Right     
##  2 L            Left      
##  3 R            Right     
##  4 R            Right     
##  5 R            Right     
##  6 L            Left      
##  7 L            Left      
##  8 R            Right     
##  9 R            Right     
## 10 R            Right     
## # … with 2,229 more rows
```

---

## Caution with pip operator

Why does 


```r
pitch$mean_spin
```

```
## Warning: Unknown or uninitialised column: `mean_spin`.
```

```
## NULL
```

not return a real-valued summary?

--

- When we use the piping operator like we have been, the data is only ever being
changed within 
- We only ever look at this new variable in the previous chunk.
- It has not been created globally into the dataset itself


---
- To do this, you need to create your new column by declaring it as its own variable.

```r
pitch$mean_spin &lt;- mean(pitch$spin_rate)
```


---

## `mutate` OR `summarize`?

Both commands introduce new variables - so which one should we use?

.pull-left[
`mutate` 

- **adds variables** to the existing data set

- The resulting variables must have the **same length** as the original data

- e.g. use for transformations, combinations of multiple variables

]

.pull-right[
`summarize` 

- **creates aggregates** of the original data

- The number of rows of the new dataset is determined by the number of combinations of the grouping structure. 

- The number of columns is determined by the number of grouping variables and the summary statistics.
]

---

## Shortcuts


`summarize(n = n())` is equivalent to `tally()` 


```r
pitch %&gt;% tally()
pitch %&gt;% summarize(n=n())
```


`group_by(playerid, action_result) %&gt;% summarize(n = n())` is equivalent to `count(playerid, action_result)`


```r
pitch %&gt;% count(playerid, action_result)
pitch %&gt;% group_by(playerid, action_result) %&gt;% summarize(n=n())
```
---
class: inverse
## Your Turn (10 min) 


Based on your (limited) knowledge of baseball, you determine what is a "successful" curveball.
Then determine what pitchers pitched the most successful curveballs!

Note: There are many different ways of answering this question. None are wrong and you don't need to know anything about baseball to try. Consider criteria that it needs to meet. Ex. A successful curveball needs to be above 90 mph in velocity and have over 3100 rpms in spin rate.

utilize the sum() function to add up all your curveballs!
---

## One Solution


```r
SScurve &lt;- pitch %&gt;%
  select("playerid", "action_result", "ab_result", "adj_h") %&gt;%  
  arrange(desc(playerid)) %&gt;% mutate(successfulCU = ifelse(
    (adj_h &lt; .3 &amp; ab_result != "\\N" ) | 
      (action_result %in% c("C","S","F")), 1, 0)) %&gt;%
#Consider a success any strike and any batted ball resulting in a 
#adj_h less than the league average of .300 BABIP (according to MLB.com).
  group_by(playerid) %&gt;% mutate(totalSSCU=sum(successfulCU)) %&gt;% 
  mutate(percentSSCU=totalSSCU / n())
SScurve
```

```
## # A tibble: 2,239 × 7
## # Groups:   playerid [65]
##    playerid action_result ab_result adj_h successfulCU totalSSCU percentSSCU
##       &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1    16669 C             "\\N"      0               1         2       0.5  
##  2    16669 B             "\\N"      0               0         2       0.5  
##  3    16669 B             "\\N"      0               0         2       0.5  
##  4    16669 C             "\\N"      0               1         2       0.5  
##  5    15686 S             "K"        0               1         1       1    
##  6    15540 X             "2B"       0.88            0        19       0.576
##  7    15540 S             "\\N"      0               1        19       0.576
##  8    15540 F             "\\N"      0               1        19       0.576
##  9    15540 B             "\\N"      0               0        19       0.576
## 10    15540 S             "\\N"      0               1        19       0.576
## # … with 2,229 more rows
```

---
## Solution (Cont)

```r
#Calculate successful curveball percentages
percentages &lt;- distinct(.data = SScurve, playerid, totalSSCU, percentSSCU)
#Look at some graphs to see what the data actually looks like now. 
library(rbokeh)
library(quanteda)
ggplot(data = percentages) + geom_point(aes(x = percentSSCU, y = totalSSCU, 
                                            colour = playerid))
```

![](2-dplyr_files/figure-html/unnamed-chunk-17-1.png)&lt;!-- --&gt;

---

## Solution (Cont.)

```r
#Filter down to get the best pitchers with a minimum of 50 curveballs thrown 
#(our median)
qualifiedPercentages &lt;- percentages %&gt;% filter(totalSSCU &gt; 50) %&gt;% 
  arrange(desc(percentSSCU))
figure() %&gt;%
  ly_points(x = percentSSCU, y = totalSSCU, color = playerid,
            data = qualifiedPercentages, hover = list(playerid, totalSSCU, 
                                                      percentSSCU), 
            legend = FALSE)
```

<div id="htmlwidget-39838abb5072389b08dc" style="width:504px;height:216px;" class="rbokeh html-widget"></div>
<script type="application/json" data-for="htmlwidget-39838abb5072389b08dc">{"x":{"elementid":"73c93acb8e252e1f3a2b8d5ab52e6302","modeltype":"Plot","modelid":"926626c9bdc00054aea0fffd8a0ecc9b","docid":"dcb7dcf48c234ed16758c09674c64f8c","docs_json":{"dcb7dcf48c234ed16758c09674c64f8c":{"version":"0.12.5","title":"Bokeh Figure","roots":{"root_ids":["926626c9bdc00054aea0fffd8a0ecc9b"],"references":[{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","attributes":{"id":"926626c9bdc00054aea0fffd8a0ecc9b","sizing_mode":"scale_both","x_range":{"type":"Range1d","id":"67df38bf7c600ffe8b27c9d1adb1d86d"},"y_range":{"type":"Range1d","id":"c6ce9f75de3fedfd68a92d926724b82b"},"left":[{"type":"LinearAxis","id":"d5232d3ff9c580b7820e8473f5506bb8"}],"below":[{"type":"LinearAxis","id":"ebc22a6d6ec96352973fb350232cc2a0"}],"right":[],"above":[],"renderers":[{"type":"BoxAnnotation","id":"1d9d7efe1f64aca2429bead2f532db96"},{"type":"GlyphRenderer","id":"27357ccb46013fa9272714bfa7f08c7a"},{"type":"LinearAxis","id":"ebc22a6d6ec96352973fb350232cc2a0"},{"type":"Grid","id":"582000aee246b45b099fb3132e481843"},{"type":"LinearAxis","id":"d5232d3ff9c580b7820e8473f5506bb8"},{"type":"Grid","id":"1b2a3d02ef3f4316f72c756d73b504f2"}],"extra_y_ranges":{},"extra_x_ranges":{},"tags":[],"min_border_left":4,"min_border_right":4,"min_border_top":4,"min_border_bottom":4,"lod_threshold":null,"toolbar":{"type":"Toolbar","id":"857c9f573a98fac1f3dcb6cc3782781f"},"tool_events":{"type":"ToolEvents","id":"09183d3fb35ee69094a193b0547010a3"}},"subtype":"Figure"},{"type":"Toolbar","id":"857c9f573a98fac1f3dcb6cc3782781f","attributes":{"id":"857c9f573a98fac1f3dcb6cc3782781f","tags":[],"active_drag":"auto","active_scroll":"auto","active_tap":"auto","tools":[{"type":"PanTool","id":"d61b5932c0581d35a2b5ad229325d516"},{"type":"WheelZoomTool","id":"6fae3ed06e156a1aeec0d8ba7664af30"},{"type":"BoxZoomTool","id":"1f172c40df1d1790df8482a5fec532d3"},{"type":"ResetTool","id":"7d2c49b613c0d8979d1dae2cf77f8aef"},{"type":"SaveTool","id":"07c01ac852af21084a2c81a27cd77754"},{"type":"HelpTool","id":"9b43944b94b44b2128e11dd785bc1da1"},{"type":"HoverTool","id":"46a44fef1ea4fe008ddb4c91f92d1dca"}],"logo":null}},{"type":"PanTool","id":"d61b5932c0581d35a2b5ad229325d516","attributes":{"id":"d61b5932c0581d35a2b5ad229325d516","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"dimensions":"both"}},{"type":"ToolEvents","id":"09183d3fb35ee69094a193b0547010a3","attributes":{"id":"09183d3fb35ee69094a193b0547010a3","tags":[]},"geometries":[]},{"type":"WheelZoomTool","id":"6fae3ed06e156a1aeec0d8ba7664af30","attributes":{"id":"6fae3ed06e156a1aeec0d8ba7664af30","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"dimensions":"both"}},{"type":"BoxAnnotation","id":"1d9d7efe1f64aca2429bead2f532db96","attributes":{"id":"1d9d7efe1f64aca2429bead2f532db96","tags":[],"line_color":{"units":"data","value":"black"},"line_alpha":{"units":"data","value":1},"fill_color":{"units":"data","value":"lightgrey"},"fill_alpha":{"units":"data","value":0.5},"line_dash":[4,4],"line_width":{"units":"data","value":2},"level":"overlay","top_units":"screen","bottom_units":"screen","left_units":"screen","right_units":"screen","render_mode":"css"}},{"type":"BoxZoomTool","id":"1f172c40df1d1790df8482a5fec532d3","attributes":{"id":"1f172c40df1d1790df8482a5fec532d3","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"overlay":{"type":"BoxAnnotation","id":"1d9d7efe1f64aca2429bead2f532db96"}}},{"type":"ResetTool","id":"7d2c49b613c0d8979d1dae2cf77f8aef","attributes":{"id":"7d2c49b613c0d8979d1dae2cf77f8aef","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"}}},{"type":"SaveTool","id":"07c01ac852af21084a2c81a27cd77754","attributes":{"id":"07c01ac852af21084a2c81a27cd77754","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"}}},{"type":"HelpTool","id":"9b43944b94b44b2128e11dd785bc1da1","attributes":{"id":"9b43944b94b44b2128e11dd785bc1da1","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"redirect":"https://hafen.github.io/rbokeh/","help_tooltip":"Click to learn more about rbokeh."}},{"type":"HoverTool","id":"46a44fef1ea4fe008ddb4c91f92d1dca","attributes":{"id":"46a44fef1ea4fe008ddb4c91f92d1dca","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"renderers":[{"type":"GlyphRenderer","id":"27357ccb46013fa9272714bfa7f08c7a"}],"names":[],"anchor":"center","attachment":"horizontal","line_policy":"prev","mode":"mouse","point_policy":"snap_to_data","tooltips":[["playerid","@hover_col_1"],["totalSSCU","@hover_col_2"],["percentSSCU","@hover_col_3"]]}},{"type":"ColumnDataSource","id":"9641ef1dcee07f10ad3f743f3104a140","attributes":{"id":"9641ef1dcee07f10ad3f743f3104a140","tags":[],"column_names":["x","y","line_color","fill_color","hover_col_1","hover_col_2","hover_col_3"],"selected":[],"data":{"x":[0.666666666666667,0.634615384615385,0.621848739495798,0.603351955307263,0.543814432989691,0.53030303030303],"y":[60,66,74,108,211,70],"line_color":["#66C2A4","#3CA96F","#50B689","#05712F","#00441B","#50B689"],"fill_color":["#66C2A4","#3CA96F","#50B689","#05712F","#00441B","#50B689"],"hover_col_1":[" 1030"," 4878"," 2850","10045","14344"," 3138"],"hover_col_2":[" 60"," 66"," 74","108","211"," 70"],"hover_col_3":["0.6666667","0.6346154","0.6218487","0.6033520","0.5438144","0.5303030"]}}},{"type":"Circle","id":"66473fcb5d12956dbf2748a258ed5ba6","attributes":{"id":"66473fcb5d12956dbf2748a258ed5ba6","tags":[],"size":{"units":"screen","value":10},"line_alpha":{"units":"data","value":1},"fill_alpha":{"units":"data","value":0.5},"x":{"units":"data","field":"x"},"y":{"units":"data","field":"y"},"line_color":{"units":"data","field":"line_color"},"fill_color":{"units":"data","field":"fill_color"}}},{"type":"Circle","id":"37b6acbe0c3dbe207f608080a8fc29fa","attributes":{"id":"37b6acbe0c3dbe207f608080a8fc29fa","tags":[],"size":{"units":"screen","value":10},"line_alpha":{"units":"data","value":1},"fill_alpha":{"units":"data","value":0.5},"x":{"units":"data","field":"x"},"y":{"units":"data","field":"y"},"line_color":{"units":"data","value":"#e1e1e1"},"fill_color":{"units":"data","value":"#e1e1e1"}}},{"type":"Circle","id":"d61d4902f878a2c41b3a2689ec4cfc8e","attributes":{"id":"d61d4902f878a2c41b3a2689ec4cfc8e","tags":[],"size":{"units":"screen","value":10},"line_alpha":{"units":"data","value":1},"fill_alpha":{"units":"data","value":1},"x":{"units":"data","field":"x"},"y":{"units":"data","field":"y"},"line_color":{"units":"data","field":"line_color"},"fill_color":{"units":"data","field":"fill_color"}}},{"type":"GlyphRenderer","id":"27357ccb46013fa9272714bfa7f08c7a","attributes":{"id":"27357ccb46013fa9272714bfa7f08c7a","tags":[],"selection_glyph":null,"nonselection_glyph":{"type":"Circle","id":"37b6acbe0c3dbe207f608080a8fc29fa"},"hover_glyph":{"type":"Circle","id":"d61d4902f878a2c41b3a2689ec4cfc8e"},"name":null,"data_source":{"type":"ColumnDataSource","id":"9641ef1dcee07f10ad3f743f3104a140"},"glyph":{"type":"Circle","id":"66473fcb5d12956dbf2748a258ed5ba6"}}},{"type":"Range1d","id":"67df38bf7c600ffe8b27c9d1adb1d86d","attributes":{"id":"67df38bf7c600ffe8b27c9d1adb1d86d","tags":[],"start":0.520757575757576,"end":0.676212121212121}},{"type":"Range1d","id":"c6ce9f75de3fedfd68a92d926724b82b","attributes":{"id":"c6ce9f75de3fedfd68a92d926724b82b","tags":[],"start":49.43,"end":221.57}},{"type":"LinearAxis","id":"ebc22a6d6ec96352973fb350232cc2a0","attributes":{"id":"ebc22a6d6ec96352973fb350232cc2a0","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"axis_label":"percentSSCU","formatter":{"type":"BasicTickFormatter","id":"337b7df8f6649eceac94850ea78e7655"},"ticker":{"type":"BasicTicker","id":"26f7a27e74195f959aa84e8496264fc6"},"visible":true,"axis_label_text_font_size":"12pt"}},{"type":"BasicTickFormatter","id":"337b7df8f6649eceac94850ea78e7655","attributes":{"id":"337b7df8f6649eceac94850ea78e7655","tags":[]}},{"type":"BasicTicker","id":"26f7a27e74195f959aa84e8496264fc6","attributes":{"id":"26f7a27e74195f959aa84e8496264fc6","tags":[],"num_minor_ticks":5}},{"type":"Grid","id":"582000aee246b45b099fb3132e481843","attributes":{"id":"582000aee246b45b099fb3132e481843","tags":[],"dimension":0,"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"ticker":{"type":"BasicTicker","id":"26f7a27e74195f959aa84e8496264fc6"}}},{"type":"LinearAxis","id":"d5232d3ff9c580b7820e8473f5506bb8","attributes":{"id":"d5232d3ff9c580b7820e8473f5506bb8","tags":[],"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"axis_label":"totalSSCU","formatter":{"type":"BasicTickFormatter","id":"86cd5027c6c2c7a8f0bf76cec6efdb13"},"ticker":{"type":"BasicTicker","id":"ca310fd2549cd372423bedae6c5bfec7"},"visible":true,"axis_label_text_font_size":"12pt"}},{"type":"BasicTickFormatter","id":"86cd5027c6c2c7a8f0bf76cec6efdb13","attributes":{"id":"86cd5027c6c2c7a8f0bf76cec6efdb13","tags":[]}},{"type":"BasicTicker","id":"ca310fd2549cd372423bedae6c5bfec7","attributes":{"id":"ca310fd2549cd372423bedae6c5bfec7","tags":[],"num_minor_ticks":5}},{"type":"Grid","id":"1b2a3d02ef3f4316f72c756d73b504f2","attributes":{"id":"1b2a3d02ef3f4316f72c756d73b504f2","tags":[],"dimension":1,"plot":{"type":"Plot","id":"926626c9bdc00054aea0fffd8a0ecc9b","subtype":"Figure"},"ticker":{"type":"BasicTicker","id":"ca310fd2549cd372423bedae6c5bfec7"}}}]}}},"debug":false},"evals":[],"jsHooks":[]}</script>



---
class: inverse

##  Your Turn

The dataset `ChickWeight` is part of the core packages that come with R 

**Hint**: `data(ChickWeight)` gets the data into your active session.

From the help file:

&gt; four groups of chicks on different protein diets. The body weights of the chicks were measured at birth and every second day thereafter until day 20. They were also measured on day 21.

![](http://www.kenaifeed.com/wp-content/uploads/2015/03/chicks.jpg)

---
class: inverse

## Your Turn

1. Create a line plot with each line representing the weight of each Chick 

2. Focus on weight on day 21. Draw side-by-side dotplots of weight by diet. 

3. **Bonus**: Use `summarize` the average weight on day 21 under each diet. Overlay the dotplots by error bars around the average weight under each diet (see `?geom_errorbar`)

**Hint** for 1: check out `?group` and consider what varible or variables you might map to this option

---

##  Solution - Q1


```r
ChickWeight %&gt;% 
  ggplot(aes(x=Time, y=weight, group=Chick, color=Diet)) +
  geom_line() + 
  facet_wrap(~Diet)
```

![](2-dplyr_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

---

##  Solution - Q2


```r
ChickWeight %&gt;%   
  filter(Time==21) %&gt;% 
  ggplot(aes(x=Diet)) +
  geom_point(aes(y=weight, color=Diet), size=3)
```

![](2-dplyr_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---

##  Solution - Q3 

First, we need a separate dataset for the summary statistics:


```r
ChickW1 &lt;- ChickWeight %&gt;% 
  filter(Time==21) %&gt;% 
  group_by(Diet) %&gt;% 
  summarize(mean_weight = mean(weight, na.rm=TRUE),
            sd_weight = sd(weight, na.rm=TRUE)/n())
```

---

##  Solution - Q3 (cont)


```r
ChickWeight %&gt;% 
  filter(Time==21) %&gt;% 
  ggplot(aes(x=Diet)) +
  geom_point(aes(y=weight), size=2) +
  geom_errorbar(data= ChickW1, aes(ymin = mean_weight-1.96*sd_weight, ymax = mean_weight+1.96*sd_weight, colour = Diet), width=.3) +
  geom_point(data=ChickW1, aes(y=mean_weight, color=Diet), size=3)
```

![](2-dplyr_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---

## `Mutate` is incredibly flexible

Consider a new variable `gain`, which gives the increase in weight of a chick since birth


```r
ChickPlus &lt;- ChickWeight %&gt;% 
  group_by(Chick) %&gt;% 
  mutate(gain = weight - weight[Time == 0])
```





```
## Rows: 12
## Columns: 3
## $ weight &lt;dbl&gt; 42, 51, 59, 64, 76, 93, 106, 125, 149, 171, 199, 205
## $ Time   &lt;dbl&gt; 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 21
## $ gain   &lt;dbl&gt; 0, 9, 17, 22, 34, 51, 64, 83, 107, 129, 157, 163
```

---

## Plotting weight gain


```r
ChickPlus %&gt;% 
  ggplot(aes(x = Time, y = gain, group = Chick)) + 
  geom_line(aes(color=Diet)) +
  facet_wrap(~Diet)
```

![](2-dplyr_files/figure-html/unnamed-chunk-26-1.png)&lt;!-- --&gt;

---

## Re-cap

- getting used to `dplyr` actions can take a bit of time and practice

- recognize keywords and match them to `dplyr` functions

- incorporate `dplyr` functions in your regular workflow - the long-term benefits are there, promise!




&lt;!-- ## Are replicates similar? --&gt;

&lt;!-- ```{r fig.width = 4.5, fig.height=4.5} --&gt;
&lt;!-- reps &lt;- french_fries %&gt;%  --&gt;
&lt;!--   group_by(time, subject, treatment) %&gt;% --&gt;
&lt;!--   summarise(potato_diff = diff(potato), --&gt;
&lt;!--             potato = mean(potato)) --&gt;

&lt;!-- reps --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Are replicates similar? (contd.) --&gt;

&lt;!-- ```{r fig.height=4, warning=FALSE} --&gt;
&lt;!-- reps %&gt;%  --&gt;
&lt;!--   ggplot(aes(x = potato, y = potato_diff, colour = as.numeric(time))) +  --&gt;
&lt;!--   facet_wrap(~subject) + --&gt;
&lt;!--   geom_hline(aes(yintercept=0)) + --&gt;
&lt;!--   geom_point()  --&gt;
&lt;!-- ``` --&gt;


&lt;!-- ## Another Solution  --&gt;
&lt;!-- For a numeric approach, we could compute means across subjects for each week and compare those values: --&gt;

&lt;!-- ```{r purl=FALSE} --&gt;
&lt;!-- ffm &lt;- french_fries %&gt;%  --&gt;
&lt;!--   group_by(time) %&gt;%  --&gt;
&lt;!--   summarise(potato = mean(potato,  na.rm=TRUE), --&gt;
&lt;!--             buttery = mean(buttery,  na.rm=TRUE), --&gt;
&lt;!--             painty = mean(painty,  na.rm=TRUE)) --&gt;

&lt;!-- ffm --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Another Solution (cont) --&gt;

&lt;!-- ```{r fig.height=3,  purl=FALSE} --&gt;

&lt;!-- ffm %&gt;% --&gt;
&lt;!--   ggplot(aes(x = time, y = potato)) +  --&gt;
&lt;!--   geom_point(colour = "blue", size=3) + --&gt;
&lt;!--   geom_point(aes(y = buttery), colour = "forestgreen", size=3) + --&gt;
&lt;!--   geom_point(aes(y = painty), colour = "red", size=3) + --&gt;
&lt;!--   ylab("Score") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This doesn't seem like an elegant or efficient way of answering the question: the data is in an awkward form! --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Another option --&gt;

&lt;!-- The package `GGally` has an implementation of a scatterplot matrix using ggplot2: --&gt;

&lt;!-- ```{r fig.height=4, warning=FALSE} --&gt;
&lt;!-- GGally::ggpairs(data = french_fries[ ,5:9]) --&gt;
&lt;!-- ``` --&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
