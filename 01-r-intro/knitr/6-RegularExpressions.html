<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Regular Expressions</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Regular Expressions
]

---




## Regular Expressions 


&lt;img src="images/email.png" class="cover" width=1600&gt;
`\(\\\)` `\(\\\)` `\(\\\)` `\(\\\)` `\(\\\)` `\(\\\)`
#### Regular Expressions are a sequence of characters that match a pattern in text.



---

## [xkcd #208](https://xkcd.com/208/)


&lt;img src="https://imgs.xkcd.com/comics/regular_expressions.png" height=500&gt;


---

## Regular Expressions

- Regular expressions (regex, regexp) is a sequence of characters that form a search pattern

- Originated in 1950s. American mathematician Stephen Kleene formalized the description of a regular language.

-  Common usage with Unix text processing utilities ed, an editor, and grep (global regular expression print), a filter.

- R language provides this capability through `grep`, `gsub`, ...

---
## Example: State names

`state.name` is a built in dataset within R that contains all the U.S. state names.


```r
data(state)
```

How many state names contain the pattern "ne"?


```r
grep(pattern = "ne", state.name)
```

```
## [1]  7 19 23 42
```

```r
state.name[7]
```

```
## [1] "Connecticut"
```

```r
grep(pattern = "ne", state.name, value = TRUE)
```

```
## [1] "Connecticut" "Maine"       "Minnesota"   "Tennessee"
```

---

## Example

We donâ€™t care about the casing so we will make our pattern more promiscuous.


```r
grep(pattern = "[nN]e", state.name, value = TRUE)
```

```
##  [1] "Connecticut"   "Maine"         "Minnesota"     "Nebraska"     
##  [5] "Nevada"        "New Hampshire" "New Jersey"    "New Mexico"   
##  [9] "New York"      "Tennessee"
```

---

## Basics of regular expressions

| expression          | meaning          |
----------------------------|:---------------------------- |
| ordinary characters | match themselves |
|  `$ ^ { [ ( ) ] } * + ? \`      |   special characters    |
| `[abc]` | matches single letter from "a", "b", or "c" |
| `[^abc]` | matches any single letter other than "a", "b", and "c" |
| `[a-gm]` | matches any single letter out of "a", "b", ... "g" or "m" |
| `[a-z][0-9]`   | matches one lower case letter followed by a digit|

---

## Basics of regular expressions (cont'd)

| expression          | meaning          |
----------------------------|:---------------------------- |
| `\x` | match a hexadecimal number |
| `\s` | whitespace|
| ^ | starting position within the string |
| $ | ending position with in the string |
| `&lt; &gt;` | start, end of a word |
| `\t \r \v \n` | tab, carriage return, vertical tab, new line |
| `\d` | represents a digit |

---
## Multipliers

- `?` indicates there is **zero or one** of the preceding element, eg `colou?r` matches "color" or "colour"

- `*` indicates there is **zero or more** of the preceding element, eg `ab*c` matches "ac", "abc", "abbc", "abbbc", ...

- `+` indicates there is **one or more** of the preceding element, eg `ab+c` matches "abc", "abbc", "abbbc", ...

- `.` matches any **single** character, eg `a.c` matches "abc" or "atc"

- `{n}` indicates the preceding element is matched exactly *n* times

- `{n,}` indicates the preceding element is matched *n* or more times

- `{n,m}` indicates the preceding element is matched at least *n* times, but not more than *m* times



---
## Advanced Patterns

see `?regex`

* `[:alpha:]` Any alphabetic character

* `[:lower:]` Any lowercase character

* `[:upper:]` Any uppercase character

* `[:digit:]` Any digit

* `[:alnum:]` Any alphanumeric character (alphabetic or digit)

* `[:blank:]` Any white space character (space, tab, vertical tab)

* `[:graph:]` Any printable character, except space

* `[:print:]` Any printable character, including the space

* `[:punct:]` Any punctuation (i.e., a printable character that is not white space or alphanumeric)

* `[:cntrl:]` Any nonprintable character

---

## Examples

What do these regular expressions do?

`.at`

`[hc]at`

`[^t]at`

`[^hc]at`

`^[S]tat`

`[S]tat$`


---

## Trickier Examples

What do these regular expressions do?

`^s.*`

`[A-Z]\{3,\}`

`[bB]ar ?[cC]hart`

`^[0-9]{5}$`

`^(\d{3}-\d{3}-\d{4})*$`

&lt;!-- `(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})` - might be a little to difficult!! --&gt;



---

## Regular expressions in R

Patterns &amp; Matches

* Find pattern: &lt;code&gt;grep, regexpr, gregexpr&lt;/code&gt;

* Pattern replacement: &lt;code&gt;gsub (pattern, replacement, x)&lt;/code&gt;

```
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)

gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
     fixed = FALSE, useBytes = FALSE)
```

---
class: inverse

## Your Turn

1. How many state names contain one or two S's?

2. For any state that has a name in the form `New ----`, replace `New` with `Old`.


---

## Extracting pieces from a regular expression

- parentheses `( )` group a pattern of interest together

- using `\\1`, `\\2`, `\\3`, ... we can extract the first, second, third ... pattern

Imagine want to extract some sample data that has been coded into our sample names.

For example, X1P10N2AFD0 encodes the experiment, pig number, pen, tissue, and day.


```r
meta &lt;- read.table("https://unl-statistics.github.io/R-workshops/01-r-intro/data/meta.txt")
head(meta)
```

```
##    label       Group numOtus
## 27  0.03 X1P10N2ACD4    5802
## 28  0.03 X1P10N2AFD0    5802
## 29  0.03 X1P10N2AFD4    5802
## 30  0.03 X1P10N2AID4    5802
## 31  0.03 X1P11N2ACD4    5802
## 32  0.03 X1P11N2AFD0    5802
```

---

## Example

Imagine, we want to extract the day number for each row.

We use the expression `D` as cue; the number after that is the day:


```r
meta$day &lt;- gsub('.*D([:digit:]*)','\\1', meta$Group)
head(meta$day)
```

```
## [1] "4" "0" "4" "4" "4" "0"
```


---
class: inverse

## Your Turn

Extract the pen number, experiment, and tissue for each row.



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
